VERTEX SHADER: 


in: 
vertex: vec3
normal: vec3
color: vec3
texCoord: vec2

out: 
frontColor: vec4	
vtexCoord: vec2


uniform: 
modelViewProjectionMatrix: mat4
normalMatrix: mat3  (	de object a eye)		vec3 N = normalize(normalMatrix * normal);



altres: 
- gl_Position: vec4




||||||||||||||||||||||||||||||||||||||||||||
FRAGMENT SHADER: 

in: 
frontColor

out: 
fragColor


altres: 
gl_FragCoord (READ ONLY)
gl_FragDepth (es pot escriure)


|||||||||||||||||||||||||||||||||||||||||||||
uniforms que es raonable que puguin anar als dos:

unfiform float time; 
uniform vec3 boundingBoxMin;
uniform vec3 boundingBoxMax;
uniform vec2 mousePosition;  (window space)






|||||||||||||||||||||||||||||||||||||||||||
OTHER: 
En GLARENASL: blau es el z
sinusoidal: w=2PI/PERIOD (speed*temps (wt) -> radians es angle)  movement: Asin(wt)  (2PI when freq is in Hz)   (es fa amb suma)  (abs() quan nomes volem la ona positiva (anira el doble de rapid))    velocity: AwCos(wt)	(w frequencia)	
Supported component names: 	{x, y, z, w} (ex: points, normals)
				{r, g, b, a} (colors)
				{s, t, p, q} (textures)
Matrius en vertical
PI = acos(-1)
rotate es fa desde els axis (per tant suara de fer translacio abans i despres)
en clipping invertir Z posa lo de darrere a davant -> en window gl_FragDepth=1-gl_FragCoord.z;
Coordenades dispositiu (gl_FragCoord) la z va de 0 a 1
normalize(normalMatrix * normal);



FUNCIONS QUE ES PODEN CRIDAR: 
fract(x) 	-> part fraccionaria
mod(x,y) 	-> x modul y
mix(a,b,t)	-> interpolacio a, b ponderada per t -> (a+t(b-a))   t [0,1]    a b pot ser vectors
sin(x)
length(resta dels dos punts) -> per exemple retorna diagonal
A PARTIR DE CLIPING SCALING NO TE SENTIT SCALE Z


Exercicis dificils: 
Color gradient ((x - (bMIN)) / (bMAx - bMIN))
oscillate




